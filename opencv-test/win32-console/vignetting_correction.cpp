#include "vignetting_correction.h"

// distance between 2 pts
double dist(cv::Point a, cv::Point b)
{
	return sqrt(pow((a.x - b.x), 2) + pow((a.y - b.y), 2));
}

double max_dist(const cv::Size& size, const cv::Point& pt)
{
	auto max_dist = dist(cv::Point(0, 0), pt);
	max_dist = cv::max(max_dist, dist(cv::Point(size.width, 0), pt));
	max_dist = cv::max(max_dist, dist(cv::Point(0, size.height), pt));
	return cv::max(max_dist, dist(cv::Point(size.width, size.height), pt));
}

void generateRngGradient(cv::Mat& gradient, double radius, double power, double rng)
{
	srand(time(0));

	auto center = cv::Point(gradient.size().width / 2, gradient.size().height / 2);
	auto radius_max = radius * max_dist(gradient.size(), center);
	const int steps = gradient.channels();
	auto ptr = gradient.ptr<double>(0);
	for (int r = 0; r < gradient.rows; r++) {
		for (int c = 0; c < gradient.cols; c++) {
			auto dist_rate = dist(center, cv::Point(c, r)) / radius_max;
			dist_rate *= power;
			for (int ch = 0; ch < steps; ch++) {
				auto g = dist_rate + (rng / 2 - rng * rand() / RAND_MAX);
				g = std::min((double)1.0f, std::max((double)0.0f, g));
				*ptr = pow(cos(g), 4);
				ptr++;
			}
		}
	}
}

void generateGradient(cv::Mat& gradient, double sigma)
{
	// pure gradient Mat can be generated by gaussian kernel
	auto rows = gradient.rows;
	auto cols = gradient.cols;

	auto hori = cv::getGaussianKernel(cols, sigma * cols); //default type is CV_64F
	auto vert = cv::getGaussianKernel(rows, sigma * rows);

	// transpose and multiply 2 arrays
	auto expr = vert * hori.t();

	// normalization
	double min_val, max_val = 0;
	cv::minMaxLoc(expr, &min_val, &max_val);

	auto gauss2d = expr / max_val;

	// increase channels
	std::vector<cv::Mat> chs;
	for (int i = 0; i < gradient.channels(); i++)
		chs.push_back(gauss2d);
	cv::merge(chs, gradient);
}

void normalization_debug()
{
	int cols = 256;
	int rows = 256;

	bool use_image = false;
	cv::Mat image;

	if (use_image) {
		// The lenna image only contains 3 channels BGR
		image = cv::imread("../Lenna_test_image.png", cv::IMREAD_COLOR);
		if (image.empty())
			return;
		cols = image.cols;
		rows = image.rows;
	}

	cv::Mat filter = cv::Mat(rows, cols, CV_64FC3, cv::Scalar(1, 1, 1));
	// generate gradient mat as vignetting filter for source simulation
	generateGradient(filter, 0.3f);
	cv::Mat filter1;
	filter.copyTo(filter1);
	cv::imshow("filter1", filter1);
	generateRngGradient(filter, 1.0f, 1.1f, 0.05f);
	cv::imshow("filter", filter);

	// ref simulate 200 prediction contains 150~250 variable vignetting from source lens
	double pred = 200.0f;
	double range = 100.0f;
	cv::Mat ref = cv::Mat(rows, cols, CV_8UC3, cv::Scalar(pred, pred, pred));
	// use convert, alpha is scale, beta is shift
	filter.convertTo(ref, CV_8UC3, range, pred - range / 2);
	// for-loop given rng 200~240 for reference pixel values
	/*uchar* ref_ptr = ref.data;
	for (int c = 0; c < cols; c++) {
		for (int r = 0; r < rows; r++) {
			for (int ch = 0; ch < 3; ch++) {
				*ref_ptr = (uchar)(200.0f + (rand() % 40));
				ref_ptr++;
			}
		}
	}*/

	if (cols * rows <= 256) {
		std::cout << "ref type:" << ref.type() << std::endl;
		std::cout << "ref:" << std::endl << ref << std::endl;
	}
	else
		cv::imshow("ref", ref);

	//scale method, scal=pred/ref, result=src*scal
	cv::Mat scal;
	ref.convertTo(scal, CV_32FC3);
	scal = pred / scal;
	if (cols * rows <= 256) {
		std::cout << "scal type:" << scal.type() << std::endl;
		std::cout << "scal:" << std::endl << scal << std::endl;
	}
	else {
		// float points are ratio based on pred, may exceed 1.0 that imshow cannot display
		cv::imshow("scal", scal);
	}

	//correction method, corr=ref/pred, result=src/corr
	cv::Mat corr;
	// use alpha let ref*1/pred, beta is shift
	ref.convertTo(corr, CV_32FC3, 1.0f / pred);
	if (cols * rows <= 256) {
		std::cout << "corr type:" << corr.type() << std::endl;
		std::cout << "corr:" << std::endl << corr << std::endl;
	}
	else {
		// float points are ratio based on pred, may exceed 1.0 that imshow cannot display
		cv::imshow("corr", corr);
	}

	// source with dark corner to apply vignetting correction
	// use flat color to get visualizable demonstration
	cv::Mat src = cv::Mat(rows, cols, CV_32FC3, cv::Scalar(192, 192, 192));
	if (image.empty() == false) {
		image.convertTo(src, CV_32FC3);
		cv::imshow("img", image);
	}

	cv::Mat res1;
	//actu.convertTo(res1, CV_32FC3);
	res1 = src.mul(scal);
	//res1.convertTo(res1, CV_8UC3);
	if (cols * rows <= 256)
		std::cout << "res1:" << std::endl << res1 << std::endl;
	else {
		res1.convertTo(res1, CV_8UC3);
		cv::imshow("res1", res1);
	}

	cv::Mat res2;
	//actu.convertTo(res2, CV_32FC3);
	res2 = src / corr;
	//res2.convertTo(res2, CV_8UC3);
	if (cols * rows <= 256)
		std::cout << "res2:" << std::endl << res2 << std::endl;
	else {
		res2.convertTo(res2, CV_8UC3);
		cv::imshow("res2", res2);
	}


	while (cv::waitKey(100) == -1) {

	}
}
